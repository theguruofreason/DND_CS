-- DnDCS classes --
local DndCSClasses = {}

-- enum setup
function DndCSClasses.enum(tbl)
    local length = #tbl
    for i = 1, length do
        local v = tbl[i]
        tbl[v] = i
        tbl[i] = v
    end
    return tbl
end

DndCSClasses.Proficiency = DndCSClasses.enum {
  "NOT_PROFICIENT",
  "PROFICIENT",
  "EXPERTISE"
}

DndCSClasses.Attributes = {
  defaults = {
    str = 0,
    dex = 0,
    con = 0,
    int = 0,
    wis = 0,
    cha = 0
  }
}
function DndCSClasses.Attributes:new (o)
  return setmetatable(
  o or {},
  {
    __index = function(table, key)
      return DndCSClasses.Attributes.defaults[key]
    end
  })
end

DndCSClasses.Saves = {
  defaults = {
    str = false,
    dex = false,
    con = false,
    int = false,
    wis = false,
    cha = false,
  }
}
function DndCSClasses.Saves:new (o)
  return setmetatable(
  o or {},
  {
    __index = function(table, key)
      return DndCSClasses.Saves.defaults[key]
    end
  })
end

DndCSClasses.Skills = {
  defaults = {
      acrobatics = DndCSClasses.Proficiency.NOT_PROFICIENT,
      animal_handling = DndCSClasses.Proficiency.NOT_PROFICIENT,
      arcana = DndCSClasses.Proficiency.NOT_PROFICIENT,
      athletics = DndCSClasses.Proficiency.NOT_PROFICIENT,
      deception = DndCSClasses.Proficiency.NOT_PROFICIENT,
      history = DndCSClasses.Proficiency.NOT_PROFICIENT,
      insight = DndCSClasses.Proficiency.NOT_PROFICIENT,
      intimidation = DndCSClasses.Proficiency.NOT_PROFICIENT,
      investigation = DndCSClasses.Proficiency.NOT_PROFICIENT,
      medicine = DndCSClasses.Proficiency.NOT_PROFICIENT,
      nature = DndCSClasses.Proficiency.NOT_PROFICIENT,
      perception = DndCSClasses.Proficiency.NOT_PROFICIENT,
      performance = DndCSClasses.Proficiency.NOT_PROFICIENT,
      persuasion = DndCSClasses.Proficiency.NOT_PROFICIENT,
      religion = DndCSClasses.Proficiency.NOT_PROFICIENT,
      slight_of_hand = DndCSClasses.Proficiency.NOT_PROFICIENT,
      stealth = DndCSClasses.Proficiency.NOT_PROFICIENT,
      survival = DndCSClasses.Proficiency.NOT_PROFICIENT
    },
  mt = {
    __index = function(table, key)
      return self.defaults[key]
    end
  }
}
function DndCSClasses.Skills:new(o)
  return setmetatable(o or {}, self.mt)
end

DndCSClasses.skill_to_att = {
  acrobatics = "dex",
  animal_handling = "wis",
  arcana = "int",
  athletics = "str",
  deception = "cha",
  history = "int",
  insight = "wis",
  intimidation = "cha",
  investigation = "int",
  medicine = "wis",
  nature = "int",
  perception = "wis",
  performance = "cha",
  persuasion = "cha",
  religion = "int",
  slight_of_hand = "dex",
  stealth = "dex",
  survival = "wis"
}

DndCSClasses.PC = {
  defaults = {
    cs_panel_active = false,
    cs_panel_page = 1,
    char_name = "",
    level = 1,
    class = "",
    inspiration = 0,
    proficiency_bonus = 0,
    attributes = DndCSClasses.Attributes.defaults,
    saves = DndCSClasses.Saves.defaults,
    skills = DndCSClasses.Skills.defaults,
    passive_perception = 10,
    ac = 10,
    initiative = 0,
    speed = 30,
    hp_current = 0,
    hp_max = 0,
    hp_temp = 0,
    hit_dice_current = 0,
    hit_dice_max = 0,
    hit_dice_d = 8,
    death_saves_successes = 0,
    death_saves_failures = 0,
    attacks = {}
  },
  direct_editables = {
    "char_name",
    "level",
    "class",
    "inspiration",
    "proficiency_bonus",
    "passive_perception",
    "ac",
    "initiative",
    "speed",
    "hp_current",
    "hp_max",
    "hp_temp",
    "hit_dice_current",
    "hit_dice_max",
    "hit_dice_d",
    "attacks"
  }
}
DndCSClasses.PC.mt = {
  __index = function(table, key)
    return DndCSClasses.PC.defaults[key]
  end
}
function DndCSClasses.PC:new (o)
  o = o or {}
  setmetatable(o or {}, self.mt)
  o.attributes = DndCSClasses.Attributes:new(o.attributes)
  o.saves = DndCSClasses.Saves:new(o.saves)
  o.skills = DndCSClasses.Skills:new(o.skills)
  return o
end

DndCSClasses.ActivePC = {
  steam_name = "",
  color = nil,
  rolling = false
}
function DndCSClasses.ActivePC:new (o)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  return o
end
function DndCSClasses.ActivePC:setColor(color)
  self.color = color
end

DndCSClasses.Position = {
  type = "Position",
  x = 0,
  y = 0,
  z = 0,
  __tostring = function(self)
    return string.format("<Position: {%d,%d,%d}>", self.x, self.y, self.z)
  end,
  __eq = function(self, o)
    eq = true
    for key, val in pairs(self) do
      if o[key] ~= val then
        eq = false
        log(string.format"%s %s", key, val)
        break
      end
    end
    for key, val in pairs(o) do
      if self[key] ~= val then
        eq = false
        log(string.format"%s %s", key, val)
        break
      end
    end
    return eq
  end,
  __add = function(self, o)
    assert(type(o) == type(table), string.format("Bad variable type: Cannot add %s and %s", self.type, type(o)))
    if o.mt ~= Position.mt then
      assert(false, string.format("Bad variable type: Cannot add %s to Position.", type(o)))
    end
    local x = self.x + o.x
    local y = self.y + o.y
    local z = self.z + o.z
    return Position.new({x=x,y=y,z=z})
  end,
  new = function(o)
    return setmetatable(
    o or {},
    {
      __index = function (table, key)
        return DndCSClasses.Position[key]
      end,
      __add = DndCSClasses.Position.__add,
      __eq = DndCSClasses.Position.__eq,
      __tostring = DndCSClasses.Position.__tostring
    })
  end,
  __sub = function(self, o)
    assert(type(o) == type(table), string.format("Bad variable type: Cannot add %s and %s", self.type, type(o)))
    if o.mt ~= Position.mt then
      assert(false, string.format("Bad variable type: Cannot add %s to Position.", type(o)))
    end
    local x = self.x - o.x
    local y = self.y - o.y
    local z = self.z - o.z
    return Position.new({x=x,y=y,z=z})
  end,
}

return DndCSClasses

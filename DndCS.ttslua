--[[ Lua code. See documentation: https://api.tabletopsimulator.com/ ]]--
local UIData = require("/DndCS/UIData")
local DndCSClasses = require("/DndCS/Classes")
local DndCS = {}
-- data --

DndCS.dndCS = {
  pc_data = {},
  active_pcs = {},
  gm = {}
}

-- dndPC functions --

function DndCS.maybeCreatePlayerData(player)
  if DndCS.dndCS.pc_data[player.steam_id] == nil then
    log(string.format("Data not found for %s", player.steam_name))
    DndCS.dndCS.pc_data[player.steam_id] = DndCSClasses.PC:new()
    log(string.format("Data created for %s", player.steam_name))
  else
    log(string.format("Found data for %s", player.steam_name))
  end
end

function DndCS.activatePlayer(player)
  log(string.format("dndPC: Activating %s - %s", player.steam_id, player.steam_name))
  DndCS.dndCS.active_pcs[player.steam_id] = DndCSClasses.ActivePC:new{
    steam_name = player.steam_name,
    color = player.color
  }
  if (player.color ~= "Grey" and player.color ~= "Black") then
    xml = UI.getXmlTable()
    xml = DndCS.createInactiveCSPanel(player, xml)
    xml = DndCS.createActiveCSPanel(player, xml)
    UI.setXmlTable(xml, _)
  end
  log(string.format("dndPC: %s - %s Activated!", player.steam_id, player.steam_name))
end

-- helper functions --

function DndCS.ensureUiAssetsExist()
  customAssets = UI.getCustomAssets()
  for _, asset in pairs(UIData.uiAssets) do
    found = false
    for _, existingAsset in ipairs(customAssets) do
      found = (existingAsset.name == asset.name)
      if found then
        break
      end
    end
    if not found then
      table.insert(customAssets, asset)
    end
  end
  UI.setCustomAssets(customAssets)
end

-- sys functions --

function onSave()
  data = {dndCS = DndCS.dndCS}
  log(data.dndCS.pc_data)
  save_data = JSON.encode(data)
  return save_data
end

function onLoad(save_state)
  if save_state ~= nil and save_state ~= "" then
    data = JSON.decode(save_state)
    if data.dndCS ~= nil then
      DndCS.dndCS = data.dndCS
      for _, pc in pairs(DndCS.dndCS.pc_data) do
        setmetatable(pc, DndCSClasses.PC.mt)
      end
    end
  else
    log("Failed to load save state. State was blank or nil.")
  end
  DndCS.ensureUiAssetsExist()
  for _, playerRef in ipairs(Player.getPlayers()) do
    DndCS.maybeCreatePlayerData(playerRef)
    DndCS.activatePlayer(playerRef)
  end
end

function onPlayerConnect(player)
  DndCS.maybeCreatePlayerData(player)
  DndCS.activatePlayer(player)
end

function onPlayerDisconnect(player)
  log(player.steam_name .. " disconnected!")
  dndCS.active_pcs[player.steam_id] = nil
end

function onPlayerChangeColor(player_color)
  for _, playerRef in ipairs(Player.getPlayers()) do
    if playerRef.color == player_color then
      DndCS.dndCS.active_pcs[playerRef.steam_id]:setColor(playerRef.color)
      xml = UI.getXmlTable()
      xml = DndCS.createInactiveCSPanel(playerRef, xml)
      xml = DndCS.createActiveCSPanel(playerRef, xml)
      UI.setXmlTable(xml, _)
    end
  end
end

-- DND CS functions --

function DndCS.createInactiveCSPanel(player, xml)
  if (player.color == "Grey" or player.color == "Black") then
    return xml
  end
  log(DndCS.dndCS.pc_data[player.steam_id])
  inactive_panel_attributes = UIData.inactive_panel(player, DndCS.dndCS.pc_data[player.steam_id].cs_panel_active)
  panel_exists = false
  for _, item in pairs(xml) do
    if item["attributes"]["id"] == inactive_panel_attributes["attributes"]["id"] then
      panel_exists = true
      log("found existing panel: " .. item["attributes"]["id"])
      break
    end
  end
  if not panel_exists then
    table.insert(xml, inactive_panel_attributes)
    log("created inactive CS Panel for " .. player.color)
  end
  return xml
end

function DndCS.createActiveCSPanel(player, xml)
  if (player.color == "Grey" or player.color == "Black") then
    return xml
  end
  active_panel_attributes = UIData.active_panel(player, DndCS.dndCS.pc_data[player.steam_id].cs_panel_active)
  active_panel_attributes = DndCS.populateCharacterSheetUi(player.color, DndCS.dndCS.pc_data[player.steam_id], active_panel_attributes)
  panel_exists = false
  for _, item in pairs(xml) do
    if item["attributes"]["id"] == active_panel_attributes["attributes"]["id"] then
      panel_exists = true
      log("found existing panel: " .. item["attributes"]["id"])
    end
  end
  if not panel_exists then
    table.insert(xml, active_panel_attributes)
    log("created active CS Panel for " .. player.color)
  end
  return xml
end

function DndCS.populateAttributeUi(player_data, att)
  return function(ui_element)
    ui_element.attributes.text = player_data.attributes[att]
    return ui_element
  end
end

function DndCS.populateAttributeBonusUi(player_data, att)
  return function(ui_element)
    local bonus = math.floor(player_data.attributes[att] / 2 - 5)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function DndCS.populateAttributeSaveToggleUi(player_data, att)
  return function(ui_element)
    ui_element.attributes.isOn = player_data.saves[att]
    return ui_element
  end
end

function DndCS.populateSkillProficientUi(player_data, skill)
  return function(ui_element)
    ui_element.attributes.isOn = (player_data.skills[skill] == DndCSClasses.Proficiency["PROFICIENT"] or player_data.skills[skill] == DndCSClasses.Proficiency["EXPERTISE"]) and true or false
    return  ui_element
  end
end

function DndCS.populateNameAndClassUi(player_color, player_data, xml)
  -- TODO
end

function DndCS.uiElementIdToFunction(color, player_data)
  functionLookupTable = {}
  for att, _ in pairs(UIData.attributes) do
    functionLookupTable["cs_"..att.."_"..color] = DndCS.populateAttributeUi(player_data, att)
    functionLookupTable["cs_"..att.."_bonus_"..color] = DndCS.populateAttributeBonusUi(player_data, att)
    functionLookupTable["cs_st_"..att.."_toggle_"..color] = DndCS.populateAttributeSaveToggleUi(player_data, att)
  end
  for skill, _ in pairs(UIData.skills) do
    functionLookupTable["cs_skill_"..skill.."_toggle_"..color] = DndCS.populateSkillProficientUi(player_data, skill)
  end
  return functionLookupTable
end

function DndCS.populateCharacterSheetUi(player_color, player_data, xml)
  attributes = UIData.attributes
  skills = UIData.skills
  elementIdToFunction = DndCS.uiElementIdToFunction(player_color, player_data)
  for i, element in pairs(xml.children) do
    if elementIdToFunction[element.attributes.id] ~= nil then
      xml.children[i] = elementIdToFunction[element.attributes.id](element)
    else
      log("Failed to find "..element.attributes.id.." in elementIdToFunction lookup.")
    end
  end
  return xml
end

function toggleCSPane(player, mouse_button, button_name)
  DndCS.dndCS.pc_data[player.steam_id].cs_panel_active = not DndCS.dndCS.pc_data[player.steam_id].cs_panel_active
  active = DndCS.dndCS.pc_data[player.steam_id].cs_panel_active
  UI.setAttribute("cs_inactive_" .. player.color, "active", not active)
  UI.setAttribute("cs_active_" .. player.color, "active", active)
end

function charNameChange(player, new_name)
  DndCS.dndCS.pc_data[player.steam_id].name = new_name
end

function lvlChange(player, new_level)
  DndCS.dndCS.pc_data[player.steam_id].level = new_level
end

function classChange(player, new_class)
  DndCS.dndCS.pc_data[player.steam_id].class = new_class
end

function attributeChange(player, att_val, attribute_input_id)
  if att_val == "" then
    log("WARNING: No att_val for "..attribute_input_id.." from "..player.color.."!!!")
  end
  att = string.sub(attribute_input_id, 4, 6)
  DndCS.dndCS.pc_data[player.steam_id].attributes[att] = att_val
  log(DndCS.dndCS.pc_data[player.steam_id].attributes)
  log(DndCSClasses.PC.defaults.attributes)
  bonus = math.floor(att_val / 2 - 5)
  bonus_string = (bonus > 0) and "+" .. tostring(bonus) or tostring(bonus)
  UI.setValue("cs_" .. att .. "_bonus_" .. player.color, bonus_string)
end

function inspirationChange(player, insp_val, attribute_input_id)
  DndCS.dndCS.pc_data[player.steam_id].attributes.inspiration = insp_val
end

function proficiencyChange(player, prof_val, attribute_input_id)
  DndCS.dndCS.pc_data[player.steam_id].attributes.proficiency_bonus = prof_val
end

function savingThrowToggle(player, toggle, st_input_id)
  att = string.sub(st_input_id, 7, 9)
  DndCS.dndCS.pc_data[player.steam_id].saves[att] = toggle
end

function skillToggle(player, toggle, skill_input_id)
  last = string.find(skill_input_id, "_toggle") - 1
  skill_name = string.sub(skill_input_id, 10, last)
  DndCS.dndCS.pc_data[player.steam_id].skills[skill_name] = (toggle == "True") and DndCSClasses.Proficiency.PROFICIENT or DndCSClasses.Proficiency.NOT_PROFICIENT
end

return DndCS

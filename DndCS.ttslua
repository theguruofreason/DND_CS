local UIData = require("/DndCS/UIData")
local DndCSClasses = require("/DndCS/Classes")
local Dice = require("/DndCS/Dice")
local enum = DndCSClasses.enum

-- logging --

local LOG_LEVEL = enum {
  "DEBUG",
  "INFO",
  "WARN",
  "ERROR"
}
local LEVEL = LOG_LEVEL["DEBUG"]
local log = function (value, label, tags, level)
  if level == nil then level = LOG_LEVEL["INFO"] end
  if LEVEL <= level then log(value, label, tags) end
end

-- data --

Data = {
  pc_data = {},
  gm = {}
}

-- dndPC functions --

function maybeCreatePlayerData(player)
  if Data.pc_data[player.steam_id] == nil then
    log(string.format("Data not found for %s", player.steam_name))
    Data.pc_data[player.steam_id] = DndCSClasses.PC:new()
    log(string.format("Data created for %s", player.steam_name))
  else
    log(string.format("Found data for %s", player.steam_name))
  end
end

function activatePlayer(player, xml)
  log(string.format("dndPC: Activating %s - %s", player.steam_id, player.steam_name))
  if (player.color ~= "Grey" and player.color ~= "Black") then
    if UI.getAttributes("DNDCS_UI_"..player.steam_id) == nil then
      xml = createUI(player, xml)
    end
  end
  log(string.format("dndPC: %s - %s Activated!", player.steam_id, player.steam_name))
  return xml
end

-- helper functions --

function RGBToHex(rgb)
  if rgb ~= nil then
    return string.format("[" .. "%02x%02x%02x", rgb[1]*255,rgb[2]*255,rgb[3]*255) .. "]"
  else
    return ""
  end
end

function ensureUiAssetsExist()
  customAssets = UI.getCustomAssets()
  asset_created = false
  for _, asset in pairs(UIData.uiAssets) do
    found = false
    for _, existingAsset in ipairs(customAssets) do
      found = (existingAsset.name == asset.name)
      if found then
        break
      end
    end
    if not found then
      table.insert(customAssets, asset)
      asset_created = true
    end
  end
  UI.setCustomAssets(customAssets)
  return not asset_created
end

function enforceSchema(pc_data)
  for key, _ in pairs(pc_data) do
    if DndCSClasses.PC.defaults[key] == nil then
      pc_data[key] = nil
    end
  end
end

function setXml(xml_table)
  if #xml_table == 0 then
    UI.setXml("")
  else
    UI.setXmlTable(xml_table)
  end
end

-- Depricated
function addFunctionOwnerToUiInteractibles(ui_elements)
  local funcs = {
    "onClick",
    "onMouseEnter",
    "onMouseExit",
    "onDrag",
    "onBeginDrag",
    "onEndDrag",
    "onMouseDown",
    "onMouseUp",
    "onSubmit",
    "onValueChanged",
    "onEndEdit"
  }
  for _, element in ipairs(ui_elements) do
    if element["children"] ~= nil then
      element.children = addFunctionOwnerToUiInteractibles(element.children)
    end
    if element["attributes"] ~= nil then
      for _, func in ipairs(funcs) do
        if element.attributes[func] ~= nil then
          element.attributes[func] = self.getGUID().."/"..element.attributes[func]
        end
      end
    end
  end
  return ui_elements
end

-- sys functions --

function onSave()
  data = {dndCS = Data}
  save_data = JSON.encode(data)
  return save_data
end

function onLoad(save_state)
  Wait.condition(
  function ()
    if save_state ~= nil and save_state ~= "" then
      data = JSON.decode(save_state)
      if data.dndCS ~= nil then
        Data = data.dndCS
        for i, pc in pairs(Data.pc_data) do
          Data[i] = enforceSchema(pc)
          setmetatable(pc, {
            __index = function(table, key)
              return DndCSClasses.PC.defaults[key]
            end
          })
        end
      end
    else
      log("Failed to load save state. State was blank or nil.")
    end
    local xml = UI.getXmlTable()
    for _, playerRef in ipairs(Player.getPlayers()) do
      maybeCreatePlayerData(playerRef)
      xml = activatePlayer(playerRef, xml)
    end
    setXml(xml)
    return true
  end,
  ensureUiAssetsExist,
  30,
  function () log("ensureUiAssetsExist timed out") end
  )
end

function onPlayerConnect(player)
  maybeCreatePlayerData(player)
  activatePlayer(player)
end

function onPlayerDisconnect(player)
  log(player.steam_name .. " disconnected!")
  if player.color ~= "Grey" and player.color ~= "Black" then
    xml = UI.getXmlTable()
    xml = removeCSPanels(xml, player.steam_id)
    setXml(xml)
  end
end

function onPlayerChangeColor(player_color)
  for _, player in ipairs(Player.getPlayers()) do
    if player.color == player_color then
      local steam_id = player.steam_id
      if (player_color == "Grey" or player_color == "Black") then
        log(player_color)
        UI.setAttribute("DNDCS_UI_"..player.steam_id, "visibility", "Garbage")
        return
      end
      if UI.getAttributes("DNDCS_UI_"..steam_id) == nil then
        xml = createUI(player, UI.getXmlTable())
        setXml(xml)
      end
      UI.setAttribute("DNDCS_UI_"..player.steam_id, "visibility", player_color)
    end
  end
end

-- DND CS functions --

function createUI(player, xml)
  local ui_panel = UIData.uiPanel(player)

  local inactive_panel = UIData.inactive_panel(player, not Data.pc_data[player.steam_id].cs_panel_active, self.guid)
  table.insert(ui_panel.children, inactive_panel)
  log("created inactive CS Panel for " .. player.steam_name, nil, nil, LOG_LEVEL["DEBUG"])

  local active_panel = UIData.active_panel(player, Data.pc_data[player.steam_id].cs_panel_active, self.guid)
  active_panel = populateCharacterSheetUi(active_panel, player.steam_id)
  table.insert(ui_panel.children, active_panel)
  log("created active CS Panel for " .. player.steam_name, nil, nil, LOG_LEVEL["DEBUG"])

  local advanced_options_panel = UIData.advanced_options_panel(player, "False", self.guid)
  table.insert(xml, advanced_options_panel_xml)
  log("created advanced options panel for " .. player.steam_name, nil, nil, LOG_LEVEL["DEBUG"])

  table.insert(xml, ui_panel)
  return xml
end

function setPanelVisibility(xml, panel_id, visibility)
  for i, element in pairs(xml) do
    if element.attributes.id == panel_id then
      xml[i].attributes["visibility"] = visibility
      log(string.format("set panel(%s) visibility to: %s", panel_id, visibility), nil, nil, LOG_LEVEL["DEBUG"])
      log(xml[i])
      break
    end
  end
  return xml
end

function removeCSPanels(xml, steam_id)
  for i, element in pairs(xml) do
    if element.attributes.id == "DNDCS_UI_"..steam_id then
      table.remove(xml, i)
      log("Removed CS Panel: " .. id, nil, nil, LOG_LEVEL["DEBUG"])
      break
    end
  end
  return xml
end

function populateAttributeUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.text = pc_data.attributes[att]
    return ui_element
  end
end

function populateAttributeBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function populateAttributeSaveToggleUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.isOn = pc_data.saves[att]
    return ui_element
  end
end

function populateAttributeSaveBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5) + (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function populateSkillProficientUi(pc_data, skill)
  return function(ui_element)
    ui_element.attributes.image = DndCSClasses.Proficiency[pc_data.skills[skill]]
    return ui_element
  end
end

function populateSkillBonusUi(pc_data, skill)
  return function(ui_element)
    local bonus = calculateSkillBonus(pc_data, skill)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function populateFieldUi(pc_data, field_name)
  return function(ui_element)
    ui_element.attributes.text = pc_data[field_name]
    return ui_element
  end
end

function uiElementIdToFunction(steam_id)
  pc_data = Data.pc_data[steam_id]
  functionLookupTable = {}
  for _, att in ipairs(UIData.attributes) do
    functionLookupTable["cs_"..att.."_"..steam_id] = populateAttributeUi(pc_data, att)
    functionLookupTable["cs_"..att.."_bonus_"..steam_id] = populateAttributeBonusUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_toggle_"..steam_id] = populateAttributeSaveToggleUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_bonus_"..steam_id] = populateAttributeSaveBonusUi(pc_data, att)
  end
  for _, skill in ipairs(UIData.skills) do
    functionLookupTable["cs_skill_"..skill.."_toggle_"..steam_id] = populateSkillProficientUi(pc_data, skill)
    functionLookupTable["cs_skill_"..skill.."_"..steam_id] = populateSkillBonusUi(pc_data, skill)
  end
  for _, field_name in pairs(DndCSClasses.PC.direct_editables) do
    functionLookupTable["cs_"..field_name.."_"..steam_id] = populateFieldUi(pc_data, field_name)
  end
  return functionLookupTable
end

function populateCharacterSheetUi(active_panel_xml, steam_id)
  player_data = Data.pc_data[steam_id]
  local omissions = {
    "toggle_button_active",
    "advanced_options_toggle",
    "cs_page"
  }
  local elementIdToFunction = uiElementIdToFunction(steam_id)
  for i, element in pairs(active_panel_xml.children) do
    if elementIdToFunction[element.attributes.id] ~= nil then
      active_panel_xml.children[i] = elementIdToFunction[element.attributes.id](element)
    else
      local found = false
      for _, omission in ipairs(omissions) do
        if string.find(element.attributes.id, omission) then
          found = true
          break
        end
      end
      if not found then
        log("Failed to find "..element.attributes.id.." in elementIdToFunction lookup.", nil, nil, LOG_LEVEL["DEBUG"])
      end
    end
  end
  return active_panel_xml
end

function toggleCSPane(player, mouse_button, button_name)
  local active = Data.pc_data[player.steam_id].cs_panel_active
  local inactiveID, activeID = "cs_inactive_" .. player.steam_id, "cs_active_" .. player.steam_id
  if active then
    UI.show(inactiveID)
    UI.hide(activeID)
  else
    UI.hide(inactiveID)
    UI.show(activeID)
  end
  Data.pc_data[player.steam_id].cs_panel_active = not active
end

function toggleAdvancedOptionsPane(player, mouse_button, button_name)
  local id = "cs_advanced_options_panel_" .. player.steam_id
  local active = UI.getAttribute(id, "active") == "true"
  if active then
    UI.hide(id)
  else
    UI.show(id)
  end
end

function attributeChange(player, att_val, attribute_input_id)
  if att_val == "" then
    log("WARNING: No att_val for "..attribute_input_id.." from "..player.color.."!!!", nil, nil, LOG_LEVEL["WARN"])
    return
  end
  local _, _, att = attribute_input_id:find("cs_(%a+)_"..player.steam_id)
  Data.pc_data[player.steam_id].attributes[att] = att_val
  local bonus = math.floor(att_val / 2 - 5)
  local bonus_string = (bonus >= 0) and "+" .. tostring(bonus) or tostring(bonus)
  UI.setValue("cs_" .. att .. "_bonus_" .. player.steam_id, bonus_string)
  recalculateSkillBonuses(Data.pc_data[player.steam_id], player.steam_id)
  setSavingThrowBonus(Data.pc_data[player.steam_id], player.steam_id, att)
end

function savingThrowToggle(player, toggle, st_input_id)
  local _, _, att = st_input_id:find("st_(%a+)_toggle")
  Data.pc_data[player.steam_id].saves[att] = (toggle == "True")
  setSavingThrowBonus(Data.pc_data[player.steam_id], player.steam_id, att)
end

function pcEditVal(player, val, ui_input_id)
  _, _, field_name = ui_input_id:find("cs_(.-)_"..player.steam_id)
  pc_data = Data.pc_data[player.steam_id]
  pc_data[field_name] = val
end

function skillToggle(player, mouse_button, skill_input_id)
  local _, _, skill_name = skill_input_id:find("skill_(.-)_toggle")
  local current_val = Data.pc_data[player.steam_id].skills[skill_name]
  local new_val = (current_val + 1 > #DndCSClasses.Proficiency) and 1 or current_val + 1
  Data.pc_data[player.steam_id].skills[skill_name] = new_val
  setSkillBonus(Data.pc_data[player.steam_id], player.steam_id, skill_name)
  UI.setAttributes(
  skill_input_id,
  {
    image = DndCSClasses.Proficiency[new_val]
  }
  )
end

function proficiencyChange(player, val)
  Data.pc_data[player.steam_id].proficiency_bonus = tonumber(val)
  for _, att in ipairs(UIData.attributes) do
    setSavingThrowBonus(Data.pc_data[player.steam_id], player.steam_id, att)
  end
  for _, skill in ipairs(UIData.skills) do
    setSkillBonus(Data.pc_data[player.steam_id], player.steam_id, skill)
  end
end

function rollSavingThrow(player, mouse_button, tag_id)
  local _, _, att = tag_id:find("st_(%a+)_bonus")
  local pc_data = Data.pc_data[player.steam_id]
  local bonus = calculateSavingThrowBonus(pc_data, att)
  local message = string.format(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a %s saving throw: ", player.steam_name, att:upper())
  Dice.click(player.steam_id, Dice.DIE_TYPE[20], Dice.RollStatus:new({
    message = message,
    bonus = bonus,
    baseTransform = player.getHandTransform(),
    allowMultiroll = true,
    individualBonus = true,
    showMaxMin = true
  }))
end

function rollSkillCheck(player, mouse_button, tag_id)
  local _, _, skill = tag_id:find("skill_(.-)_"..player.steam_id)
  local pc_data = Data.pc_data[player.steam_id]
  local bonus = calculateSkillBonus(pc_data, skill)
  local message = string.format(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a(n) %s skill check: ", player.steam_name, skill:gsub("_"," "))
  Dice.click(player.steam_id, Dice.DIE_TYPE[20], Dice.RollStatus:new({
    message = message,
    bonus = bonus,
    baseTransform = player.getHandTransform(),
    allowMultiroll = true,
    individualBonus = true,
    showMaxMin = true
  }))
end

function recalculateSkillBonuses(pc_data, steam_id)
  for _, skill in ipairs(UIData.skills) do
    setSkillBonus(pc_data, steam_id, skill)
  end
end

function setSkillBonus(pc_data, steam_id, skill)
  local att = DndCSClasses.skill_to_att[skill]
  local bonus = calculateSkillBonus(pc_data, skill)
  UI.setAttribute(
  "cs_skill_" .. skill .. "_" .. steam_id,
  "text",
  bonus >= 0 and "+"..bonus or bonus)
end

function calculateSkillBonus(pc_data, skill)
  att = DndCSClasses.skill_to_att[skill]
  return (math.floor(pc_data.attributes[att] / 2 - 5)) +
  (pc_data.skills[skill] - 1) * (pc_data.proficiency_bonus)
end

function setSavingThrowBonus(pc_data, steam_id, att)
  local bonus = calculateSavingThrowBonus(pc_data, att)
  UI.setAttribute(
  "cs_st_"..att.."_bonus_"..steam_id,
  "text",
  bonus >= 0 and "+"..bonus or bonus
  )
end

function calculateSavingThrowBonus(pc_data, att)
  return(
  math.floor(pc_data.attributes[att] / 2 - 5) +
  (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
  )
end

return DndCS

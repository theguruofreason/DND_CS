--[[ Lua code. See documentation: https://api.tabletopsimulator.com/ ]]--
local UIData = require("/DndCS/UIData")
local DndCSClasses = require("/DndCS/Classes")
local enum = DndCSClasses.enum
local DndCS = {}

DIE_CLEANUP_DELAY = 5
DIE_MULTIROLL = false
ROLL_DELAY = 1
DICE_CLEANUP_DELAY = 3

-- data --

DndCS.data = {
  pc_data = {},
  active_pcs = {},
  gm = {}
}

-- dndPC functions --

function DndCS.maybeCreatePlayerData(player)
  if DndCS.data.pc_data[player.steam_id] == nil then
    log(string.format("Data not found for %s", player.steam_name))
    DndCS.data.pc_data[player.steam_id] = DndCSClasses.PC:new()
    log(string.format("Data created for %s", player.steam_name))
  else
    log(string.format("Found data for %s", player.steam_name))
  end
end

function DndCS.activatePlayer(player)
  log(string.format("dndPC: Activating %s - %s", player.steam_id, player.steam_name))
  DndCS.data.active_pcs[player.steam_id] = DndCSClasses.ActivePC:new{
    steam_name = player.steam_name,
    color = player.color
  }
  if (player.color ~= "Grey" and player.color ~= "Black") then
    xml = UI.getXmlTable()
    xml = DndCS.createInactiveCSPanel(player, xml)
    xml = DndCS.createActiveCSPanel(player, xml)
    UI.setXmlTable(xml, _)
  end
  log(string.format("dndPC: %s - %s Activated!", player.steam_id, player.steam_name))
end

-- helper functions --

function RGBToHex(rgb)
    if rgb ~= nil then
        return string.format("[" .. "%02x%02x%02x", rgb[1]*255,rgb[2]*255,rgb[3]*255) .. "]"
    else
        return ""
    end
end

function wait(time)
    local start = os.time()
    repeat coroutine.yield(0) until os.time() > start + time
end

function DndCS.ensureUiAssetsExist()
  customAssets = UI.getCustomAssets()
  asset_created = false
  for _, asset in pairs(UIData.uiAssets) do
    found = false
    for _, existingAsset in ipairs(customAssets) do
      found = (existingAsset.name == asset.name)
      if found then
        break
      end
    end
    if not found then
      table.insert(customAssets, asset)
      asset_created = true
    end
  end
  UI.setCustomAssets(customAssets)
  return not asset_created
end

function DndCS.enforceSchema(pc_data)
  for key, _ in pairs(pc_data) do
    if DndCSClasses.PC.defaults[key] == nil then
      pc_data[key] = nil
    end
  end
end

function DndCS.setXml(xml_table)
  if #xml == 0 then
    UI.setXml("")
  else
    UI.setXmlTable(xml)
  end
end

function DndCS.addFunctionOwnerToUiInteractibles(ui_element)
  if ui_element["children"] ~= nil then
    ui_element.children = DndCS.addFunctionOwnerToUiInteractibles(ui_element.children)
  end
  if ui_element["attributes"] ~= nil then
    if ui_element.attributes["onClick"] ~= nil then
      ui_element.attributes.onClick = self.getGUID().."/"..ui_element.attributes.onClick
    elseif ui_element.attributes["onValueChanged"] ~= nil then
      ui_element.attributes.onValueChanged = self.getGUID().."/"..ui_element.attributes.onValueChanged
    elseif ui_element.attributes["onEndEdit"] ~= nil then
      ui_element.attributes.onEndEdit = self.getGUID().."/"..ui_element.attributes.onEndEdit
    end
  end
  return ui_element
end

-- sys functions --

function onSave()
  data = {dndCS = DndCS.data}
  save_data = JSON.encode(data)
  return save_data
end

function onLoad(save_state)
  Wait.condition(
    function () Wait.frames(
      function ()
        if save_state ~= nil and save_state ~= "" then
          data = JSON.decode(save_state)
          if data.dndCS ~= nil then
            DndCS.data = data.dndCS
            for i, pc in pairs(DndCS.data.pc_data) do
              DndCS.data[i] = DndCS.enforceSchema(pc)
              setmetatable(pc, DndCSClasses.PC.mt)
            end
          end
        else
          log("Failed to load save state. State was blank or nil.")
        end
        for _, playerRef in ipairs(Player.getPlayers()) do
          DndCS.maybeCreatePlayerData(playerRef)
          DndCS.activatePlayer(playerRef)
        end
      end,
      1
      )
    end,
    DndCS.ensureUiAssetsExist,
    30,
    function () log("ensureUiAssetsExist timed out") end
  )
end

function onPlayerConnect(player)
  DndCS.maybeCreatePlayerData(player)
  DndCS.activatePlayer(player)
end

function onPlayerDisconnect(player)
  log(player.steam_name .. " disconnected!")
  DndCS.data.active_pcs[player.steam_id] = nil
  if player.color ~= "Grey" and player.color ~= "Black" then
    xml = UI.getXmlTable()
    xml = DndCS.removeCSPanels(player.color, xml)
    DndCS.setXml(xml)
  end
end

function onPlayerChangeColor(player_color)
  for _, playerRef in ipairs(Player.getPlayers()) do
    if playerRef.color == player_color then
      xml = UI.getXmlTable()
      if (player_color == "Grey" or player_color == "Black") then
        xml = DndCS.removeCSPanels(DndCS.data.active_pcs[playerRef.steam_id].color, xml)
      else
        prev_color = DndCS.data.active_pcs[playerRef.steam_id].color
        if UI.getValue("cs_inactive_"..prev_color) == nil then
          xml = DndCS.createInactiveCSPanel(playerRef, xml)
          xml = DndCS.createActiveCSPanel(playerRef, xml)
        else
          DndCS.changeCSPanelsOwner(prev_color, playerRef.color)
          return
        end
      end
      DndCS.setXml(xml)
      DndCS.data.active_pcs[playerRef.steam_id]:setColor(playerRef.color)
    end
  end
end

-- DND CS functions --

function DndCS.removeCSPanels(color, xml)
  for i=#xml,1,-1 do
    id = xml[i].attributes.id
    if id == "cs_active_"..color or id == "cs_inactive_"..color then
      table.remove(xml, i)
      log("Removed CS Panel: " .. id)
    end
  end
  return xml
end

function DndCS.changeCSPanelsOwner(prev_color, new_color)
  UI.setAttributes("cs_inactive_"..prev_color, {
    id = "cs_inactive_"..playerRef.color,
    visibility = playerRef.color
  })
  UI.setAttributes("cs_active_"..prev_color, {
    id = "cs_active_"..playerRef.color,
    visibility = playerRef.color
  })
end

function DndCS.createInactiveCSPanel(player, xml)
  if (player.color == "Grey" or player.color == "Black") then
    return xml
  end
  inactive_panel_attributes = UIData.inactive_panel(player, DndCS.data.pc_data[player.steam_id].cs_panel_active)
  panel_exists = false
  for _, item in pairs(xml) do
    if item["attributes"]["id"] == inactive_panel_attributes["attributes"]["id"] then
      panel_exists = true
      log("found existing panel: " .. item["attributes"]["id"])
      break
    end
  end
  if not panel_exists then
    for i, child in pairs(inactive_panel_attributes.children) do
      inactive_panel_attributes.children[i] = DndCS.addFunctionOwnerToUiInteractibles(child)
    end
    table.insert(xml, inactive_panel_attributes)
    log("created inactive CS Panel for " .. player.color)
  end
  return xml
end

function DndCS.createActiveCSPanel(player, xml)
  if (player.color == "Grey" or player.color == "Black") then
    return xml
  end
  active_panel_attributes = UIData.active_panel(player, DndCS.data.pc_data[player.steam_id].cs_panel_active)
  active_panel_attributes = DndCS.populateCharacterSheetUi(player.color, DndCS.data.pc_data[player.steam_id], active_panel_attributes)
  panel_exists = false
  for _, item in pairs(xml) do
    if item["attributes"]["id"] == active_panel_attributes["attributes"]["id"] then
      panel_exists = true
      log("found existing panel: " .. item["attributes"]["id"])
    end
  end
  if not panel_exists then
    for i, child in pairs(active_panel_attributes.children) do
      active_panel_attributes.children[i] = DndCS.addFunctionOwnerToUiInteractibles(child)
    end
    table.insert(xml, active_panel_attributes)
    log("created active CS Panel for " .. player.color)
  end
  return xml
end

function DndCS.populateAttributeUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.text = pc_data.attributes[att]
    return ui_element
  end
end

function DndCS.populateAttributeBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function DndCS.populateAttributeSaveToggleUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.isOn = pc_data.saves[att]
    return ui_element
  end
end

function DndCS.populateAttributeSaveBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5) + (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function DndCS.populateSkillProficientUi(pc_data, skill)
  return function(ui_element)
    ui_element.attributes.image = DndCSClasses.Proficiency[pc_data.skills[skill]]
    return  ui_element
  end
end

function DndCS.populateSkillBonusUi(pc_data, skill)
  return function(ui_element)
    local bonus = DndCS.calculateSkillBonus(pc_data, skill)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return  ui_element
  end
end

function DndCS.popluateFieldUi(pc_data, field_name)
  return function(ui_element)
    ui_element.attributes.text = pc_data[field_name]
    return ui_element
  end
end

function DndCS.uiElementIdToFunction(color, pc_data)
  functionLookupTable = {}
  for _, att in ipairs(UIData.attributes) do
    functionLookupTable["cs_"..att.."_"..color] = DndCS.populateAttributeUi(pc_data, att)
    functionLookupTable["cs_"..att.."_bonus_"..color] = DndCS.populateAttributeBonusUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_toggle_"..color] = DndCS.populateAttributeSaveToggleUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_bonus_"..color] = DndCS.populateAttributeSaveBonusUi(pc_data, att)
  end
  for _, skill in ipairs(UIData.skills) do
    functionLookupTable["cs_skill_"..skill.."_toggle_"..color] = DndCS.populateSkillProficientUi(pc_data, skill)
    functionLookupTable["cs_skill_"..skill.."_"..color] = DndCS.populateSkillBonusUi(pc_data, skill)
  end
  for _, field_name in pairs(DndCSClasses.PC.direct_editables) do
    functionLookupTable["cs_"..field_name.."_"..color] = DndCS.popluateFieldUi(pc_data, field_name)
  end
  functionLookupTable["cs_proficiency_bonus_"..color] = DndCS.popluateFieldUi(pc_data, "proficiency_bonus")
  return functionLookupTable
end

function DndCS.populateCharacterSheetUi(player_color, player_data, xml)
  attributes = UIData.attributes
  skills = UIData.skills
  elementIdToFunction = DndCS.uiElementIdToFunction(player_color, player_data)
  for i, element in pairs(xml.children) do
    if element.tag == "Button" or element.attributes.id == "cs_skill_passive_perception_"..player_color then
      goto continue
    end
    if elementIdToFunction[element.attributes.id] ~= nil then
      xml.children[i] = elementIdToFunction[element.attributes.id](element)
    else
      log("Failed to find "..element.attributes.id.." in elementIdToFunction lookup.")
    end
    ::continue::
  end
  return xml
end

function toggleCSPane(player, mouse_button, button_name)
  DndCS.data.pc_data[player.steam_id].cs_panel_active = not DndCS.data.pc_data[player.steam_id].cs_panel_active
  active = DndCS.data.pc_data[player.steam_id].cs_panel_active
  UI.setAttribute("cs_inactive_" .. player.color, "active", not active)
  UI.setAttribute("cs_active_" .. player.color, "active", active)
end

function toggleAdvancedOptions(player, mouse_button, button_name)
  -- TODO
end

function attributeChange(player, att_val, attribute_input_id)
  if att_val == "" then
    log("WARNING: No att_val for "..attribute_input_id.." from "..player.color.."!!!")
    return
  end
  local _, _, att = attribute_input_id:find("cs_(%a+)_"..player.color)
  DndCS.data.pc_data[player.steam_id].attributes[att] = att_val
  local bonus = math.floor(att_val / 2 - 5)
  local bonus_string = (bonus >= 0) and "+" .. tostring(bonus) or tostring(bonus)
  UI.setValue("cs_" .. att .. "_bonus_" .. player.color, bonus_string)
  DndCS.recalculateSkillBonuses(DndCS.data.pc_data[player.steam_id], player.color)
  DndCS.setSavingThrowBonus(DndCS.data.pc_data[player.steam_id], player.color, att)
end

function savingThrowToggle(player, toggle, st_input_id)
  local _, _, att = st_input_id:find("st_(%a+)_toggle")
  DndCS.data.pc_data[player.steam_id].saves[att] = (toggle == "True")
  DndCS.setSavingThrowBonus(DndCS.data.pc_data[player.steam_id], player.color, att)
end

function pcEditVal(player, val, ui_input_id)
  field_name = ui_input_id:find("cs_(.-)_"..player.color)
  pc_data = DndCS.data.pc_data[player.steam_id]
  pc_data[field_name] = val
end

function skillToggle(player, mouse_button, skill_input_id)
  local _, _, skill_name = skill_input_id:find("skill_(.-)_toggle")
  local current_val = DndCS.data.pc_data[player.steam_id].skills[skill_name]
  local new_val = (current_val + 1 > #DndCSClasses.Proficiency) and 1 or current_val + 1
  DndCS.data.pc_data[player.steam_id].skills[skill_name] = new_val
  DndCS.setSkillBonus(DndCS.data.pc_data[player.steam_id], player.color, skill_name)
  UI.setAttributes(
    skill_input_id,
    {
      image = DndCSClasses.Proficiency[new_val]
    }
    )
end

function proficiencyChange(player, val)
  DndCS.data.pc_data[player.steam_id].proficiency_bonus = tonumber(val)
  for _, att in ipairs(UIData.attributes) do
    DndCS.setSavingThrowBonus(DndCS.data.pc_data[player.steam_id], player.color, att)
  end
  for _, skill in ipairs(UIData.skills) do
    DndCS.setSkillBonus(DndCS.data.pc_data[player.steam_id], player.color, skill)
  end
end

function rollSavingThrow(player, mouse_button, tag_id)
  local _, _, att = tag_id:find("st_(%a+)_bonus")
  local pc_data = DndCS.data.pc_data[player.steam_id]
  local bonus = DndCS.calculateSavingThrowBonus(pc_data, att)
  local message = string.format(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a %s saving throw: ", player.steam_name, att:upper())
  local die = spawnObject({
    type = "Die_20",
    position = player.getHandTransform().position,
    callback_function = function(obj) DndCS.rollDice({obj}, player.color, bonus, message) end
  })
  die.setLock(true)
end

function rollSkillCheck(player, mouse_button, tag_id)
  local _, _, skill = tag_id:find("skill_(.-)_"..player.color)
  local pc_data = DndCS.data.pc_data[player.steam_id]
  local bonus = DndCS.calculateSkillBonus(pc_data, skill)
  local message = string.format(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a(n) %s skill check: ", player.steam_name, skill:gsub("_"," "))
  local die = spawnObject({
    type = "Die_20",
    position = player.getHandTransform().position,
    callback_function = function(obj) DndCS.rollDice({obj}, player.color, bonus, message) end
  })
  die.setLock(true)
end

function DndCS.rollDice(dice, color, bonus, message)
  function coroutine_rollDice()
    wait(ROLL_DELAY)
    for _, die in ipairs(dice) do
      die.setLock(false)
      die.roll()
      wait(0.1)
    end
    DndCS.monitorDice(dice, color, bonus, message)
    return 1
  end
  startLuaCoroutine(self, "coroutine_rollDice")
end

function DndCS.monitorDice(dice, color, bonus, message)
  function coroutine_monitorDice()
    repeat
      local resting = true
      for _, die in ipairs(dice) do
        if die ~= nil and die.resting == false then
          resting = false
          break
        end
      end
      coroutine.yield(0)
    until resting == true
    DndCS.announceRoll(dice, bonus, message)
    DndCS.cleanupDice(dice)
    return 1
  end
  startLuaCoroutine(self, "coroutine_monitorDice")
end

function DndCS.announceRoll(dice, bonus, message, color)
  local total = 0
  local rolls = {}

  for i, die in ipairs(dice) do
    local value = die.getValue()
    total = total + value
    table.insert(rolls, value)
    message = message .. value .. (i ~= #dice and " + " or "")
  end
  total = total + bonus
  message = message .. string.format(" ("..(bonus >= 0 and "+%d)" or "%d)").." for a total of %d", bonus, total)
  if color ~= nil then
    broadcastToColor(message, color, {1,1,1})
  else
    broadcastToAll(message, {1,1,1})
  end
end

function DndCS.cleanupDice(dice)
  Wait.time(
  function()
    for _, die in pairs(dice) do
      die.destruct()
    end
  end
  ,
  DICE_CLEANUP_DELAY
  )
end

function DndCS.recalculateSkillBonuses(pc_data, color)
  for _, skill in ipairs(UIData.skills) do
    DndCS.setSkillBonus(pc_data, color, skill)
  end
end

function DndCS.setSkillBonus(pc_data, color, skill)
  local att = DndCSClasses.skill_to_att[skill]
  local bonus = DndCS.calculateSkillBonus(pc_data, skill)
  UI.setAttribute(
  "cs_skill_" .. skill .. "_" .. color,
  "text",
  bonus >= 0 and "+"..bonus or bonus)
end

function DndCS.calculateSkillBonus(pc_data, skill)
  att = DndCSClasses.skill_to_att[skill]
  return (math.floor(pc_data.attributes[att] / 2 - 5)) +
  (pc_data.skills[skill] - 1) * (pc_data.proficiency_bonus)
end

function DndCS.setSavingThrowBonus(pc_data, color, att)
  local bonus = DndCS.calculateSavingThrowBonus(pc_data, att)
  UI.setAttribute(
    "cs_st_"..att.."_bonus_"..color,
    "text",
    bonus >= 0 and "+"..bonus or bonus
  )
end

function DndCS.calculateSavingThrowBonus(pc_data, att)
  return(
  math.floor(pc_data.attributes[att] / 2 - 5) +
  (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
  )
end

return DndCS

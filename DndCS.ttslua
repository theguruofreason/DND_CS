local UIData = require("/DndCS/UIData")
local DndCSClasses = require("/DndCS/Classes")
local Dice = require("/DndCS/Dice")
local Version = require("/DndCS/Version")
local Logging = require("/DndCS/BetterLogging")
local log = Logging.log
local logDebug = Logging.logDebug
local logInfo = Logging.logInfo
local logWarn = Logging.logWarn
local logError = Logging.logError
local enum = require("/DndCS/Enum")

local fs = string.format



-- data --

Data = {
  pc_data = {},
  player_data = {},
  gm = {},
}

-- dndPC functions --

function maybeCreatePlayerData(player)
  if Data.pc_data[player.steam_id] == nil then
    log(fs("Data not found for %s", player.steam_name))
    Data.pc_data[player.steam_id] = DndCSClasses.PC:new()
    log(fs("Data created for %s", player.steam_name))
  else
    log(fs("Found data for %s", player.steam_name))
  end
  if Data.player_data[player.steam_id] == nil then
    Data.player_data[player.steam_id] = DndCSClasses.PlayerData:new()
  end
end

function activatePlayer(player, xml)
  log(fs("dndPC: Activating %s - %s", player.steam_id, player.steam_name))
  if (player.color ~= "Grey" and player.color ~= "Black") then
    if UI.getAttributes("DNDCS_UI_"..player.steam_id) == nil then
      xml = createUI(player, xml)
    end
  end
  log(fs("dndPC: %s - %s Activated!", player.steam_id, player.steam_name))
  return xml
end

-- helper functions --

function findElementById(xml, matchId)
  function findElement(rootElement, id)
    if rootElement.attributes ~= nil and rootElement.attributes.id == id then return rootElement end
    if rootElement.children ~= nil then
      for i, child in pairs(rootElement.children) do
        local found = findElement(child, id)
        if found ~= nil then return found end
      end
    end
    return nil
  end
  for _, element in pairs(xml) do
    local found = findElement(element, matchId)
    if found ~= nil then return found end
  end
end

function setElementById(xml, matchId)

end

function RGBToHex(rgb)
  if rgb ~= nil then
    return fs("[" .. "%02x%02x%02x", rgb[1]*255,rgb[2]*255,rgb[3]*255) .. "]"
  else
    return ""
  end
end

function ensureUiAssetsExist()
  customAssets = UI.getCustomAssets()
  asset_created = false
  for _, asset in pairs(UIData.uiAssets) do
    found = false
    for _, existingAsset in ipairs(customAssets) do
      found = (existingAsset.name == asset.name)
      if found then
        break
      end
    end
    if not found then
      table.insert(customAssets, asset)
      asset_created = true
    end
  end
  UI.setCustomAssets(customAssets)
  return not asset_created
end

function enforceSchema(pc_data)
  for key, _ in pairs(pc_data) do
    if DndCSClasses.PC.defaults[key] == nil then
      pc_data[key] = nil
    end
  end
end

function setXml(xml_table)
  if #xml_table == 0 then
    UI.setXml("")
  else
    UI.setXmlTable(xml_table)
  end
end

function maybeUpdateData(data)
  if data.pc_data == nil then data.pc_data = {} end
  if data.player_data == nil then data.player_data = {} end
  if data.gm == nil then data.gm = {} end
  return data
end

-- sys functions --

function onSave()
  data = {dndCS = Data}
  save_data = JSON.encode(data)
  return save_data
end

function onLoad(save_state)
  Wait.condition(
  function ()
  Wait.frames(
  function ()
    if save_state ~= nil and save_state ~= "" then
      data = JSON.decode(save_state)
      if data.dndCS ~= nil then
        Data = maybeUpdateData(data.dndCS)
        for i, pc in pairs(Data.pc_data) do
          Data[i] = enforceSchema(pc)
          setmetatable(pc, {
            __index = function(table, key)
              return DndCSClasses.PC.defaults[key]
            end
          })
        end
      end
    else
      log("Failed to load save state. State was blank or nil.", "WARNING")
    end
    local xml = UI.getXmlTable()
    for _, playerRef in ipairs(Player.getPlayers()) do
      maybeCreatePlayerData(playerRef)
      xml = activatePlayer(playerRef, xml)
    end
    setXml(xml)
    return true
  end,
  2
  ) end,
  ensureUiAssetsExist,
  30,
  function () log("ensureUiAssetsExist timed out.", "ERROR") end
  )
end

function onPlayerConnect(player)
  maybeCreatePlayerData(player)
  activatePlayer(player)
end

function onPlayerDisconnect(player)
  log(player.steam_name .. " disconnected!")
  if player.color ~= "Grey" and player.color ~= "Black" then
    xml = UI.getXmlTable()
    xml = removeCSPanels(xml, player.steam_id)
    setXml(xml)
  end
end

function onPlayerChangeColor(player_color)
  for _, player in ipairs(Player.getPlayers()) do
    if player.color == player_color then
      local steam_id = player.steam_id
      if (player_color == "Grey" or player_color == "Black") then
        UI.setAttribute("DNDCS_UI_"..player.steam_id, "visibility", "Garbage")
        return
      end
      if UI.getAttributes("DNDCS_UI_"..steam_id) == nil then
        xml = createUI(player, UI.getXmlTable())
        setXml(xml)
      end
      UI.setAttribute("DNDCS_UI_"..player.steam_id, "visibility", player_color)
    end
  end
end

-- DND CS functions --

function createUI(player, xml)
  local ui_panel = UIData.uiPanel(player)

  local inactive_panel = UIData.inactive_panel(player, not Data.pc_data[player.steam_id].cs_panel_active, self.guid)
  table.insert(ui_panel.children, inactive_panel)
  log("created inactive CS Panel for " .. player.steam_name, "DEBUG")

  local active_panel = UIData.active_panel(player, Data.pc_data[player.steam_id].cs_panel_active, self.guid)
  active_panel = populateCharacterSheetUi(active_panel, player.steam_id)
  table.insert(ui_panel.children, active_panel)
  log("created active CS Panel for " .. player.steam_name, "DEBUG")

  local advanced_options_panel_xml = UIData.advanced_options_panel(player, false, self.guid)
  table.insert(ui_panel.children, advanced_options_panel_xml)
  log("created advanced options panel for " .. player.steam_name, "DEBUG")

  table.insert(xml, ui_panel)
  return xml
end

function setPanelVisibility(xml, panel_id, visibility)
  for i, element in pairs(xml) do
    if element.attributes.id == panel_id then
      xml[i].attributes["visibility"] = visibility
      log(fs("set panel(%s) visibility to: %s", panel_id, visibility), "DEBUG")
      break
    end
  end
  return xml
end

function removeCSPanels(xml, steam_id)
  for i, element in pairs(xml) do
    if element.attributes.id == "DNDCS_UI_"..steam_id then
      table.remove(xml, i)
      log("Removed CS Panel: " .. "DNDCS_UI_"..steam_id, nil, nil, "DEBUG")
      break
    end
  end
  return xml
end

function populateAttributeUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.text = pc_data.attributes[att]
    return ui_element
  end
end

function populateAttributeBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function populateAttributeSaveToggleUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.isOn = pc_data.saves[att]
    return ui_element
  end
end

function populateAttributeSaveBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5) + (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function populateSkillProficientUi(pc_data, skill)
  return function(ui_element)
    ui_element.attributes.image = DndCSClasses.Proficiency[pc_data.skills[skill]]
    return ui_element
  end
end

function populateSkillBonusUi(pc_data, skill)
  return function(ui_element)
    local bonus = calculateSkillBonus(pc_data, skill)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function populateFieldUi(pc_data, field_name)
  return function(ui_element)
    if field_name == "initiative" then
      ui_element.attributes.text = (pc_data[field_name] > 0 and "+"..pc_data[field_name]) or pc_data[field_name]
      return ui_element
    end
    ui_element.attributes.text = pc_data[field_name]
    return ui_element
  end
end

function populateDeathSaveUi(pc_data, saveNum, successOrFailure)
  return function(ui_element)
    ui_element.attributes.isOn = pc_data[successOrFailure] >= saveNum and true or false
    return ui_element
  end
end

function populateClassUi(steam_id, pc_data)
  return function(ui_element)
    if #pc_data.classes == 0 then
      table.insert(ui_element.children, {
        tag = "Option",
        value = "",
        attributes = {
          id = "cs_empty_class_"..steam_id
        },
        children = {}
      })
    end
    for _, characterClass in pairs(pc_data.classes) do
      table.insert(ui_element.children, {
        tag = "Option",
        value = characterClass.className,
        attributes = {
          id = "cs_"..characterClass.className.."_class_"..steam_id
        },
        children = {}
      })
    end
    table.insert(ui_element.children, {
      tag = "Option",
      value = "New Class",
      attributes = {
        id = "cs_new_class_"..steam_id
      },
        children = {}
    })
  end
end

function uiElementIdToFunction(steam_id)
  pc_data = Data.pc_data[steam_id]
  functionLookupTable = {}
  for _, att in ipairs(UIData.attributes) do
    functionLookupTable["cs_"..att.."_"..steam_id] = populateAttributeUi(pc_data, att)
    functionLookupTable["cs_"..att.."_bonus_"..steam_id] = populateAttributeBonusUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_toggle_"..steam_id] = populateAttributeSaveToggleUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_bonus_"..steam_id] = populateAttributeSaveBonusUi(pc_data, att)
  end
  for _, skill in ipairs(UIData.skills) do
    functionLookupTable["cs_skill_"..skill.."_toggle_"..steam_id] = populateSkillProficientUi(pc_data, skill)
    functionLookupTable["cs_skill_"..skill.."_"..steam_id] = populateSkillBonusUi(pc_data, skill)
  end
  for i=1,3 do
    functionLookupTable[fs("cs_death_save_failure_%d_%s", i, steam_id)] = populateDeathSaveUi(pc_data, i, "death_save_failures")
    functionLookupTable[fs("cs_death_save_success_%d_%s", i, steam_id)] = populateDeathSaveUi(pc_data, i, "death_save_successes")
  end
  for _, field_name in pairs(DndCSClasses.PC.direct_editables) do
    functionLookupTable["cs_"..field_name.."_"..steam_id] = populateFieldUi(pc_data, field_name)
  end
  functionLookupTable["cs_class_dropdown_"..steam_id] = populateClassUi(steam_id, pc_data)
  return functionLookupTable
end

function populateCharacterSheetUi(active_panel_xml, steam_id)
  player_data = Data.pc_data[steam_id]
  local omissions = {
    "toggle_button_active",
    "advanced_options_toggle",
    "cs_page",
  }
  local elementIdToFunction = uiElementIdToFunction(steam_id)
  local function populateFields(element)
    if element.children ~= nil then
      for _, child in pairs(element.children) do populateFields(child) end
    end
    if elementIdToFunction[element.attributes.id] ~= nil then
      element = elementIdToFunction[element.attributes.id](element)
    elseif element.attributes.id ~= nil then
      local found = false
      for _, omission in ipairs(omissions) do
        if string.find(element.attributes.id, omission) then
          found = true
          break
        end
      end
      if not found then
        log("Failed to find "..element.attributes.id.." in elementIdToFunction lookup.", nil, nil, "DEBUG")
      end
    end
  end
  populateFields(active_panel_xml)
  return active_panel_xml
end

function toggleCSPane(player, mouse_button, button_name)
  local active = Data.pc_data[player.steam_id].cs_panel_active
  local inactiveID, activeID = "cs_inactive_" .. player.steam_id, "cs_active_" .. player.steam_id
  if active then
    UI.show(inactiveID)
    UI.hide(activeID)
    if UI.getAttribute("cs_advanced_options_panel_" .. player.steam_id, "active") == "true" then
      UI.hide("cs_advanced_options_panel_" .. player.steam_id)
    end
  else
    UI.hide(inactiveID)
    UI.show(activeID)
  end
  Data.pc_data[player.steam_id].cs_panel_active = not active
end

function toggleAdvancedOptionsPane(player, mouse_button, button_name)
  local id = "cs_advanced_options_panel_" .. player.steam_id
  local active = UI.getAttribute(id, "active")
  if UI.getAttribute(id, "active"):lower() == "true" then
    UI.setAttribute(id, "active", false)
    UI.setAttribute("cs_advanced_options_toggle_"..player.steam_id, "isOn", false)
  else
    UI.setAttribute(id, "active", true)
  end
end

function calculateAttributeBonus(att_val)
  return math.floor(att_val / 2 - 5)
end

function attributeChange(player, att_val, attribute_input_id)
  if att_val == "" then
    log("WARNING: No att_val for "..attribute_input_id.." from "..player.color.."!!!", nil, nil, "WARN")
    return
  end
  local _, _, att = attribute_input_id:find("cs_(%a+)_"..player.steam_id)
  Data.pc_data[player.steam_id].attributes[att] = att_val
  local bonus = calculateAttributeBonus(att_val)
  local bonus_string = (bonus >= 0) and "+" .. tostring(bonus) or tostring(bonus)
  UI.setValue("cs_" .. att .. "_bonus_" .. player.steam_id, bonus_string)
  recalculateSkillBonuses(Data.pc_data[player.steam_id], player.steam_id)
  setSavingThrowBonus(Data.pc_data[player.steam_id], player.steam_id, att)
end

function savingThrowToggle(player, toggle, st_input_id)
  local _, _, att = st_input_id:find("st_(%a+)_toggle")
  Data.pc_data[player.steam_id].saves[att] = (toggle == "True")
  setSavingThrowBonus(Data.pc_data[player.steam_id], player.steam_id, att)
end

function pcEditVal(player, val, ui_input_id)
  _, _, field_name = ui_input_id:find("cs_(.-)_"..player.steam_id)
  pc_data = Data.pc_data[player.steam_id]
  pc_data[field_name] = val
end

function skillToggle(player, mouse_button, skill_input_id)
  local _, _, skill_name = skill_input_id:find("skill_(.-)_toggle")
  local current_val = Data.pc_data[player.steam_id].skills[skill_name]
  local new_val = (current_val + 1 > #DndCSClasses.Proficiency) and 1 or current_val + 1
  Data.pc_data[player.steam_id].skills[skill_name] = new_val
  setSkillBonus(Data.pc_data[player.steam_id], player.steam_id, skill_name)
  UI.setAttributes(
  skill_input_id,
  {
    image = DndCSClasses.Proficiency[new_val]
  }
  )
end

function proficiencyChange(player, val)
  Data.pc_data[player.steam_id].proficiency_bonus = tonumber(val)
  for _, att in ipairs(UIData.attributes) do
    setSavingThrowBonus(Data.pc_data[player.steam_id], player.steam_id, att)
  end
  for _, skill in ipairs(UIData.skills) do
    setSkillBonus(Data.pc_data[player.steam_id], player.steam_id, skill)
  end
end

function rollAtt(player, mouse_button, tag_id)
  _, _, att = tag_id:find("cs_(%a+)_bonus")
  local pc_data = Data.pc_data[player.steam_id]
  local bonus = math.floor(pc_data.attributes[att] / 2 - 5)
  local message = fs(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a %s check: ", player.steam_name, att:upper())
  Dice.click(player.steam_id, Dice.DIE_TYPE[20], Dice.RollStatus:new({
    message = message,
    bonus = bonus,
    baseTransform = player.getHandTransform(),
    allowMultiroll = true,
    individualBonus = true,
    showMaxMin = true
  }))
end

function rollSavingThrow(player, mouse_button, tag_id)
  local _, _, att = tag_id:find("st_(%a+)_bonus")
  local pc_data = Data.pc_data[player.steam_id]
  local bonus = calculateSavingThrowBonus(pc_data, att)
  local message = fs(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a %s saving throw: ", player.steam_name, att:upper())
  Dice.click(player.steam_id, Dice.DIE_TYPE[20], Dice.RollStatus:new({
    message = message,
    bonus = bonus,
    baseTransform = player.getHandTransform(),
    allowMultiroll = true,
    individualBonus = true,
    showMaxMin = true
  }))
end

function rollSkillCheck(player, mouse_button, tag_id)
  local _, _, skill = tag_id:find("skill_(.-)_"..player.steam_id)
  local pc_data = Data.pc_data[player.steam_id]
  local bonus = calculateSkillBonus(pc_data, skill)
  local message = fs(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a(n) %s skill check: ", player.steam_name, skill:gsub("_"," "))
  Dice.click(player.steam_id, Dice.DIE_TYPE[20], Dice.RollStatus:new({
    message = message,
    bonus = bonus,
    baseTransform = player.getHandTransform(),
    allowMultiroll = true,
    individualBonus = true,
    showMaxMin = true
  }))
end

function deathSaveToggle(player, on, tag_id)
  local on = on == "True"
  local successOrFailure = tag_id:find("success") and "death_save_successes" or "death_save_failures"
  Data.pc_data[player.steam_id][successOrFailure] = Data.pc_data[player.steam_id][successOrFailure] + (on and 1 or -1)
  log(fs("%s for %s set to %d", successOrFailure, player.steam_name, Data.pc_data[player.steam_id][successOrFailure]), nil, nil, "DEBUG")
end

function recalculateSkillBonuses(pc_data, steam_id)
  for _, skill in ipairs(UIData.skills) do
    setSkillBonus(pc_data, steam_id, skill)
  end
end

function setSkillBonus(pc_data, steam_id, skill)
  local att = DndCSClasses.skill_to_att[skill]
  local bonus = calculateSkillBonus(pc_data, skill)
  UI.setAttribute(
  "cs_skill_" .. skill .. "_" .. steam_id,
  "text",
  bonus >= 0 and "+"..bonus or bonus)
end

function calculateSkillBonus(pc_data, skill)
  att = DndCSClasses.skill_to_att[skill]
  return (math.floor(pc_data.attributes[att] / 2 - 5)) +
  (pc_data.skills[skill] - 1) * (pc_data.proficiency_bonus)
end

function setSavingThrowBonus(pc_data, steam_id, att)
  local bonus = calculateSavingThrowBonus(pc_data, att)
  UI.setAttribute(
  "cs_st_"..att.."_bonus_"..steam_id,
  "text",
  bonus >= 0 and "+"..bonus or bonus
  )
end

function calculateSavingThrowBonus(pc_data, att)
  return(
  math.floor(pc_data.attributes[att] / 2 - 5) +
  (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
  )
end

function changeCSPage(player, pageMod)
  local newPage = Data.pc_data[player.steam_id].cs_panel_page + pageMod
  if newPage < 1 then newPage = UIData.numPages
  elseif newPage > UIData.numPages then newPage = 1
  end
  Data.pc_data[player.steam_id].cs_panel_page = newPage
  for i = 1, UIData.numPages do
    UI.setAttribute(string.format("cs_page_%d_"..player.steam_id,i), "active", i == newPage)
  end
end

function classDropdownChange(player, option)
  local pc_data = Data.pc_data[player.steam_id]
  if UI.getAttribute("cs_class_entry_"..player.steam_id, "active") then
    UI.hide("cs_class_entry_"..player.steam_id)
  end
  if option == "New Class" then
    UI.show("cs_class_entry_"..player.steam_id)
    pc_data.selected_class = #pc_data.classes + 1
  else
    for i, class in pairs(pc_data.classes) do
      if class.className == option then
        pc_data.selected_class = i
        UI.setAttribute("cs_level_"..player.steam_id, "text", class.classLevel ~= nil and class.classLevel or 0)
      end
    end
  end
end

function setClassName(player, name)
  Data.pc_data[player.steam_id].temp_class_name = name
end

function setClassLevel(player, level)
  Data.pc_data[player.steam_id].classes[Data.pc_data[player.steam_id].selected_class].classLevel = level
end

function saveNewClass(player)
  local steam_id = player.steam_id
  assert(Data.pc_data[steam_id].temp_class_name ~= nil, "Cannot save nil className!")
  for _, class in pairs(Data.pc_data[steam_id].classes) do
    if class.className == Data.pc_data[steam_id].temp_class_name then
      log(fs("Class (%s) already exists for player (%s)!", class.className, player.steam_name), "ERROR")
      return
    end
  end
  local xml = UI.getXmlTable()
  local classOptions = findElementById(xml, "cs_class_dropdown_"..steam_id).children
  log(classOptions)
  if classOptions[1].value == nil then table.remove(classOptions, 1) end
  for i, element in pairs(classOptions) do
    if element.attributes.id == "cs_new_class_"..steam_id then
      local tempNewClassOption = element
      classOptions[i] = {
        tag = "Option",
        value = Data.pc_data[player.steam_id].temp_class_name,
        attributes = {
          id = "cs_"..Data.pc_data[player.steam_id].temp_class_name.."_class_"..steam_id
        }
      }
      table.insert(classOptions, tempNewClassOption)
      break
    end
  end
  local pc_data = Data.pc_data[steam_id]
  table.insert(pc_data.classes, DndCSClasses.CharacterClass:new({
    className = Data.pc_data[player.steam_id].temp_class_name,
  }))
  Data.pc_data[player.steam_id].temp_class_name = nil
  Data.pc_data[player.steam_id].selected_class = 1
  setXml(xml)
  UI.setAttribute("cs_empty_class_"..steam_id, "active", false)
  UI.hide("cs_class_entry_"..steam_id)
  UI.setAttribute("cs_level_"..steam_id, "text", 0)
end

function removeClass(player)
  local pc_data = Data.pc_data[player.steam_id]
  if pc_data.selected_class == #pc_data.classes + 1 then return end
  local xml = UI.getXmlTable()
  local classOptions = findElementById(xml, "cs_class_dropdown_"..player.steam_id).children
  table.remove(classOptions, pc_data.selected_class)
  table.remove(pc_data.classes, pc_data.selected_class)
  pc_data.selected_class = pc_data.selected_class - 1
  if #classOptions == 1 then
    table.insert(classOptions, 1, {
        tag = "Option",
        value = "",
        attributes = {
          id = "cs_empty_class_"..player.steam_id
        },
        children = {}
      })
  end
  setXml(xml)
end

-- # Advanced Options # --

function setCharSheetUrl(player, val)
  Data.player_data[player.steam_id].characterSheetUrl = val
end

function importCharacterSheet(player, mouse_button, tag_id)
  local url = Data.player_data[player.steam_id].characterSheetUrl
  local getRequest = WebRequest.get(url)
  function waitForGetCharacterSheet()
    while not getRequest.is_done do
      coroutine.yield(0)
    end
    if getRequest.is_error then
      log(getRequest.error, "ERROR")
      return 1
    end
    Data.player_data[player.steam_id].characterSheetJson = getRequest.text
    parseCharacterSheet(player)
    return 1
  end
  startLuaCoroutine(self, "waitForGetCharacterSheet")
end

function parseCharacterSheet(player)
  local data = JSON.decode(Data.player_data[player.steam_id].characterSheetJson)
  if data.schema_version ~= 1 then log("Schema version not 1. This may not work...", "WARN") end
  local charData = data.character[1]
  local pc_data = Data.pc_data[player.steam_id]
  pc_data.passive_perception = (charData.passive_perception ~= nil and charData.passive_perception) or 0
  pc_data.ac = (charData.ac ~= nil and charData.ac) or 0
  pc_data.proficiency_bonus = (charData.proficiency_bonus ~= nil and tonumber(charData.proficiency_bonus)) or 0
  pc_data.char_name = (charData.character_name ~= nil and charData.character_name) or ""
  pc_data.initiative = (charData.initiative_bonus ~= nil and charData.initiative_bonus) or 0
  for att, val in pairs(charData["abilities_bonuses"][1]["abilities"]) do
    pc_data.attributes[att] = val
  end
  for skill, val in pairs(charData.skills) do
    skill = skill:gsub("-", "_")
    if UIData.skills[skill] then
      local val = tonumber(val)
      local att = DndCSClasses.skill_to_att[skill]
      local expectedBonus = calculateAttributeBonus(pc_data.attributes[att])
      if val ~= expectedBonus then
        if (val == expectedBonus + pc_data.proficiency_bonus) then
          pc_data.skills[skill] = DndCSClasses.Proficiency.PROFICIENT
        elseif (val == expectedBonus + 2 * pc_data.proficiency_bonus) then
          pc_data.skills[skill] = DndCSClasses.Proficiency.EXPERTISE
        end
      end
      log(fs("%s: %s", skill, tostring(pc_data.skills[skill])), "DEBUG")
    end
  end
  for att, bonus in pairs(charData.save_bonuses) do
    local expectedBonus = calculateSavingThrowBonus(pc_data, att)
    if (bonus ~= expectedBonus) and (bonus == (expectedBonus + pc_data.proficiency_bonus)) then
      pc_data.saves[att] = true
    else
      pc_data.saves[att] = false
    end
    log(fs("%s: %s", att, tostring(pc_data.saves[att])), "DEBUG")
  end
  if charData.hp ~= nil then
    if charData.hp[1].hp_current ~= nil then pc_data.hp_current = charData.hp[1].hp_current end
    if charData.hp[1].hp_max ~= nil then pc_data.hp_max = charData.hp[1].hp_max end
  end
  if charData.characteristics[1].speed then pc_data.speed = charData.characteristics[1].speed end
  local features_and_traits = ""
  for _, info in pairs(charData.traits) do
    features_and_traits = features_and_traits..info.."\n"
  end
  pc_data.features_and_traits = features_and_traits
  if charData.classes ~= nil then
    pc_data.classes = {}
    for _, classData in pairs(charData.classes) do
      pc_data.classes:insert(DndCSClasses.CharacterClass:new({
        className = classData["class-name"],
        classLevel = classData["class-level"],
        hitDie = classData["hit-die"],
        subClassName = classData["subclass-name"]
      }))
    end
  end
  Data.pc_data[player.steam_id] = pc_data
  xml = UI.getXmlTable()
  active_panel = {}
  for i, ui in pairs(xml) do
    for x, element in pairs(ui.children) do
      if element.attributes.id == "cs_active_"..player.steam_id then
        active_panel = populateCharacterSheetUi(element, player.steam_id)
        xml[i][x] = active_panel
        setXml(xml)
        active_panel = element
        break
      end
    end
  end
end

return DndCS

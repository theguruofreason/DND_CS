local UIData = require("/DndCS/UIData")
local DndCSClasses = require("/DndCS/Classes")
local Dice = require("/DndCS/Dice")
local enum = DndCSClasses.enum
local DndCS = {}

-- globals --

VERBOSE = true
function CS_PANEL_IDS(steam_id)
  return {
    ["cs_active_"..steam_id] = true,
    ["cs_inactive_"..steam_id] = true,
    ["cs_advanced_options_panel_"..steam_id] = true
  }
end
function CS_PANEL_ID_TO_GEN(steam_id)
  return {
    ["cs_active_"..steam_id] = DndCS.createActiveCSPanel,
    ["cs_inactive_"..steam_id] = DndCS.createInactiveCSPanel,
    ["cs_advanced_options_panel_"..steam_id] = DndCS.createAdvancedOptionsPanel
  }
end

-- logging --

function logv(value, label, tags)
  if VERBOSE then log(value, label, tags) end
end

-- data --

DndCS.data = {
  pc_data = {},
  gm = {}
}

-- dndPC functions --

function DndCS.maybeCreatePlayerData(player)
  if DndCS.data.pc_data[player.steam_id] == nil then
    logv(string.format("Data not found for %s", player.steam_name))
    DndCS.data.pc_data[player.steam_id] = DndCSClasses.PC:new()
    logv(string.format("Data created for %s", player.steam_name))
  else
    logv(string.format("Found data for %s", player.steam_name))
  end
end

function DndCS.activatePlayer(player)
  logv(string.format("dndPC: Activating %s - %s", player.steam_id, player.steam_name))
  if (player.color ~= "Grey" and player.color ~= "Black") then
    xml = UI.getXmlTable()
    for id, func in pairs(CS_PANEL_ID_TO_GEN(player.steam_id)) do
      if UI.getAttributes(id) == nil then
        xml = func(player, xml)
      end
    end
    UI.setXmlTable(xml, _)
  end
  logv(string.format("dndPC: %s - %s Activated!", player.steam_id, player.steam_name))
end

-- helper functions --

function RGBToHex(rgb)
    if rgb ~= nil then
        return string.format("[" .. "%02x%02x%02x", rgb[1]*255,rgb[2]*255,rgb[3]*255) .. "]"
    else
        return ""
    end
end

function DndCS.ensureUiAssetsExist()
  customAssets = UI.getCustomAssets()
  asset_created = false
  for _, asset in pairs(UIData.uiAssets) do
    found = false
    for _, existingAsset in ipairs(customAssets) do
      found = (existingAsset.name == asset.name)
      if found then
        break
      end
    end
    if not found then
      table.insert(customAssets, asset)
      asset_created = true
    end
  end
  UI.setCustomAssets(customAssets)
  return not asset_created
end

function DndCS.enforceSchema(pc_data)
  for key, _ in pairs(pc_data) do
    if DndCSClasses.PC.defaults[key] == nil then
      pc_data[key] = nil
    end
  end
end

function DndCS.setXml(xml_table)
  if #xml_table == 0 then
    UI.setXml("")
  else
    UI.setXmlTable(xml_table)
  end
end

function DndCS.addFunctionOwnerToUiInteractibles(ui_elements)
  local funcs = {
    "onClick",
    "onMouseEnter",
    "onMouseExit",
    "onDrag",
    "onBeginDrag",
    "onEndDrag",
    "onMouseDown",
    "onMouseUp",
    "onSubmit",
    "onValueChanged",
    "onEndEdit"
  }
  for _, element in ipairs(ui_elements) do
    if element["children"] ~= nil then
      element.children = DndCS.addFunctionOwnerToUiInteractibles(element.children)
    end
    if element["attributes"] ~= nil then
      for _, func in ipairs(funcs) do
        if element.attributes[func] ~= nil then
          element.attributes[func] = self.getGUID().."/"..element.attributes[func]
        end
      end
    end
  end
  return ui_elements
end

-- sys functions --

function onSave()
  data = {dndCS = DndCS.data}
  save_data = JSON.encode(data)
  return save_data
end

function onLoad(save_state)
  Wait.condition(
  function ()
    if save_state ~= nil and save_state ~= "" then
      data = JSON.decode(save_state)
      if data.dndCS ~= nil then
        DndCS.data = data.dndCS
        for i, pc in pairs(DndCS.data.pc_data) do
          DndCS.data[i] = DndCS.enforceSchema(pc)
          setmetatable(pc, {
            __index = function(table, key)
              return DndCSClasses.PC.defaults[key]
            end
          })
        end
      end
    else
      logv("Failed to load save state. State was blank or nil.")
    end
    for _, playerRef in ipairs(Player.getPlayers()) do
      DndCS.maybeCreatePlayerData(playerRef)
      DndCS.activatePlayer(playerRef)
    end
  end,
  DndCS.ensureUiAssetsExist,
  30,
  function () logv("ensureUiAssetsExist timed out") end
  )
end

function onPlayerConnect(player)
  DndCS.maybeCreatePlayerData(player)
  DndCS.activatePlayer(player)
end

function onPlayerDisconnect(player)
  logv(player.steam_name .. " disconnected!")
  if player.color ~= "Grey" and player.color ~= "Black" then
    xml = UI.getXmlTable()
    xml = DndCS.removeCSPanels(player.steam_id, xml)
    DndCS.setXml(xml)
  end
end

function onPlayerChangeColor(player_color)
  for _, playerRef in ipairs(Player.getPlayers()) do
    if playerRef.color == player_color then
      local steam_id = playerRef.steam_id
      xml = UI.getXmlTable()
      if (player_color == "Grey" or player_color == "Black") then
        xml = DndCS.deactivateCSPanels(steam_id, xml)
        DndCS.setXml(xml)
        return
      end
      for id, func in pairs(CS_PANEL_ID_TO_GEN(steam_id)) do
        if UI.getAttributes(id) == nil then
          func(playerRef, xml)
        end
      end
      DndCS.changeCSPanelsOwner(playerRef.steam_id, player_color)
      DndCS.setXml(xml)
    end
  end
end

-- DND CS functions --

function DndCS.deactivateCSPanels(steam_id, xml)
  ids = CS_PANEL_IDS(steam_id)
  for i=#xml,1,-1 do
    id = xml[i].attributes.id
    if ids[id] == true then
      UI.setAttribute(id, "active", false)
      logv("Deactivated CS Panel: " .. id)
    end
  end
  return xml
end

function DndCS.removeCSPanels(steam_id, xml)
  ids = CS_PANEL_IDS(steam_id)
  for i=#xml,1,-1 do
    id = xml[i].attributes.id
    if ids[id] == true then
      table.remove(xml, i)
      logv("Removed CS Panel: " .. id)
    end
  end
  return xml
end

function DndCS.changeCSPanelsOwner(steam_id, new_color)
  ids = CS_PANEL_IDS(steam_id)
  for id, _ in pairs(ids) do
    UI.setAttribute(id, "visibility", new_color)
    logv("Activated CS Panel: " .. id)
  end
  local active = DndCS.data.pc_data[steam_id].cs_panel_active
    UI.setAttribute("cs_active_"..steam_id, "active", active)
    UI.setAttribute("cs_inactive_"..steam_id, "active", not active)
end

function DndCS.createInactiveCSPanel(player, xml)
  inactive_panel_attributes = UIData.inactive_panel(player, not DndCS.data.pc_data[player.steam_id].cs_panel_active)
  inactive_panel_attributes = DndCS.addFunctionOwnerToUiInteractibles({inactive_panel_attributes})[1]
  table.insert(xml, inactive_panel_attributes)
  logv("created inactive CS Panel for " .. player.color)
  return xml
end

function DndCS.createActiveCSPanel(player, xml)
  active_panel_attributes = UIData.active_panel(player, DndCS.data.pc_data[player.steam_id].cs_panel_active)
  active_panel_attributes = DndCS.populateCharacterSheetUi(player.steam_id, DndCS.data.pc_data[player.steam_id], active_panel_attributes)
  active_panel_attributes = DndCS.addFunctionOwnerToUiInteractibles({active_panel_attributes})[1]
  table.insert(xml, active_panel_attributes)
  logv("created active CS Panel for " .. player.color)
  return xml
end

function DndCS.createAdvancedOptionsPanel(player, xml)
  local advanced_options_panel_attributes = DndCS.addFunctionOwnerToUiInteractibles({UIData.advanced_options_panel(player, "False")})[1]
  table.insert(xml, advanced_options_panel_attributes)
  logv("created advanced options panel for " .. player.color)
  return xml
end

function DndCS.populateAttributeUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.text = pc_data.attributes[att]
    return ui_element
  end
end

function DndCS.populateAttributeBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function DndCS.populateAttributeSaveToggleUi(pc_data, att)
  return function(ui_element)
    ui_element.attributes.isOn = pc_data.saves[att]
    return ui_element
  end
end

function DndCS.populateAttributeSaveBonusUi(pc_data, att)
  return function(ui_element)
    local bonus = math.floor(pc_data.attributes[att] / 2 - 5) + (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function DndCS.populateSkillProficientUi(pc_data, skill)
  return function(ui_element)
    ui_element.attributes.image = DndCSClasses.Proficiency[pc_data.skills[skill]]
    return ui_element
  end
end

function DndCS.populateSkillBonusUi(pc_data, skill)
  return function(ui_element)
    local bonus = DndCS.calculateSkillBonus(pc_data, skill)
    ui_element.attributes.text = (bonus >= 0) and "+"..bonus or bonus
    return ui_element
  end
end

function DndCS.populateFieldUi(pc_data, field_name)
  return function(ui_element)
    ui_element.attributes.text = pc_data[field_name]
    return ui_element
  end
end

function DndCS.uiElementIdToFunction(steam_id, pc_data)
  functionLookupTable = {}
  for _, att in ipairs(UIData.attributes) do
    functionLookupTable["cs_"..att.."_"..steam_id] = DndCS.populateAttributeUi(pc_data, att)
    functionLookupTable["cs_"..att.."_bonus_"..steam_id] = DndCS.populateAttributeBonusUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_toggle_"..steam_id] = DndCS.populateAttributeSaveToggleUi(pc_data, att)
    functionLookupTable["cs_st_"..att.."_bonus_"..steam_id] = DndCS.populateAttributeSaveBonusUi(pc_data, att)
  end
  for _, skill in ipairs(UIData.skills) do
    functionLookupTable["cs_skill_"..skill.."_toggle_"..steam_id] = DndCS.populateSkillProficientUi(pc_data, skill)
    functionLookupTable["cs_skill_"..skill.."_"..steam_id] = DndCS.populateSkillBonusUi(pc_data, skill)
  end
  for _, field_name in pairs(DndCSClasses.PC.direct_editables) do
    functionLookupTable["cs_"..field_name.."_"..steam_id] = DndCS.populateFieldUi(pc_data, field_name)
  end
  return functionLookupTable
end

function DndCS.populateCharacterSheetUi(player_steam_id, player_data, xml)
  local omissions = {
    "toggle_button_active",
    "advanced_options_toggle",
    "cs_page"
  }
  local attributes = UIData.attributes
  local skills = UIData.skills
  local elementIdToFunction = DndCS.uiElementIdToFunction(player_steam_id, player_data)
  for i, element in pairs(xml.children) do
    if elementIdToFunction[element.attributes.id] ~= nil then
      xml.children[i] = elementIdToFunction[element.attributes.id](element)
    else
      local found = false
      for _, omission in ipairs(omissions) do
        if string.find(element.attributes.id, omission) then
          found = true
          break
        end
      end
      if not found then
        logv("Failed to find "..element.attributes.id.." in elementIdToFunction lookup.")
      end
    end
  end
  return xml
end

function toggleCSPane(player, mouse_button, button_name)
  local active = DndCS.data.pc_data[player.steam_id].cs_panel_active
  local inactiveID, activeID = "cs_inactive_" .. player.steam_id, "cs_active_" .. player.steam_id
  local inactivePanelState = UI.getAttribute("cs_inactive_" .. player.steam_id, "active") == "true"
  local activePanelState = UI.getAttribute("cs_active_" .. player.steam_id, "active") == "true"
  if active then
    UI.show(inactiveID)
    UI.hide(activeID)
  else
    UI.hide(inactiveID)
    UI.show(activeID)
  end
  DndCS.data.pc_data[player.steam_id].cs_panel_active = not DndCS.data.pc_data[player.steam_id].cs_panel_active
end

function toggleAdvancedOptionsPane(player, mouse_button, button_name)
  local id = "cs_advanced_options_panel_" .. player.steam_id
  local active = UI.getAttribute(id, "active") == "true"
  if active then
    UI.hide(id)
  else
    UI.show(id)
  end
end

function attributeChange(player, att_val, attribute_input_id)
  if att_val == "" then
    logv("WARNING: No att_val for "..attribute_input_id.." from "..player.color.."!!!")
    return
  end
  local _, _, att = attribute_input_id:find("cs_(%a+)_"..player.steam_id)
  DndCS.data.pc_data[player.steam_id].attributes[att] = att_val
  local bonus = math.floor(att_val / 2 - 5)
  local bonus_string = (bonus >= 0) and "+" .. tostring(bonus) or tostring(bonus)
  UI.setValue("cs_" .. att .. "_bonus_" .. player.steam_id, bonus_string)
  DndCS.recalculateSkillBonuses(DndCS.data.pc_data[player.steam_id], player.steam_id)
  DndCS.setSavingThrowBonus(DndCS.data.pc_data[player.steam_id], player.steam_id, att)
end

function savingThrowToggle(player, toggle, st_input_id)
  local _, _, att = st_input_id:find("st_(%a+)_toggle")
  DndCS.data.pc_data[player.steam_id].saves[att] = (toggle == "True")
  DndCS.setSavingThrowBonus(DndCS.data.pc_data[player.steam_id], player.steam_id, att)
end

function pcEditVal(player, val, ui_input_id)
  _, _, field_name = ui_input_id:find("cs_(.-)_"..player.steam_id)
  pc_data = DndCS.data.pc_data[player.steam_id]
  pc_data[field_name] = val
end

function skillToggle(player, mouse_button, skill_input_id)
  local _, _, skill_name = skill_input_id:find("skill_(.-)_toggle")
  local current_val = DndCS.data.pc_data[player.steam_id].skills[skill_name]
  local new_val = (current_val + 1 > #DndCSClasses.Proficiency) and 1 or current_val + 1
  DndCS.data.pc_data[player.steam_id].skills[skill_name] = new_val
  DndCS.setSkillBonus(DndCS.data.pc_data[player.steam_id], player.steam_id, skill_name)
  UI.setAttributes(
    skill_input_id,
    {
      image = DndCSClasses.Proficiency[new_val]
    }
    )
end

function proficiencyChange(player, val)
  DndCS.data.pc_data[player.steam_id].proficiency_bonus = tonumber(val)
  for _, att in ipairs(UIData.attributes) do
    DndCS.setSavingThrowBonus(DndCS.data.pc_data[player.steam_id], player.steam_id, att)
  end
  for _, skill in ipairs(UIData.skills) do
    DndCS.setSkillBonus(DndCS.data.pc_data[player.steam_id], player.steam_id, skill)
  end
end

function rollSavingThrow(player, mouse_button, tag_id)
  local _, _, att = tag_id:find("st_(%a+)_bonus")
  local pc_data = DndCS.data.pc_data[player.steam_id]
  local bonus = DndCS.calculateSavingThrowBonus(pc_data, att)
  local message = string.format(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a %s saving throw: ", player.steam_name, att:upper())
  Dice.click(player.steam_id, Dice.DIE_TYPE[20], Dice.RollStatus:new({
    message = message,
    bonus = bonus,
    basePosition = player.getHandTransform().position,
    allowMultiroll = true,
    individualBonus = true,
    showMaxMin = true
  }))
end

function rollSkillCheck(player, mouse_button, tag_id)
  local _, _, skill = tag_id:find("skill_(.-)_"..player.steam_id)
  local pc_data = DndCS.data.pc_data[player.steam_id]
  local bonus = DndCS.calculateSkillBonus(pc_data, skill)
  local message = string.format(RGBToHex(stringColorToRGB(player.color)).."%s[-] rolled a(n) %s skill check: ", player.steam_name, skill:gsub("_"," "))
  local die = spawnObject({
    type = "Die_20",
    position = player.getHandTransform().position,
    callback_function = function(obj) Dice.rollDice({obj}, player, bonus, message) end
  })
  die.setLock(true)
end

function DndCS.recalculateSkillBonuses(pc_data, steam_id)
  for _, skill in ipairs(UIData.skills) do
    DndCS.setSkillBonus(pc_data, steam_id, skill)
  end
end

function DndCS.setSkillBonus(pc_data, steam_id, skill)
  local att = DndCSClasses.skill_to_att[skill]
  local bonus = DndCS.calculateSkillBonus(pc_data, skill)
  UI.setAttribute(
  "cs_skill_" .. skill .. "_" .. steam_id,
  "text",
  bonus >= 0 and "+"..bonus or bonus)
end

function DndCS.calculateSkillBonus(pc_data, skill)
  att = DndCSClasses.skill_to_att[skill]
  return (math.floor(pc_data.attributes[att] / 2 - 5)) +
  (pc_data.skills[skill] - 1) * (pc_data.proficiency_bonus)
end

function DndCS.setSavingThrowBonus(pc_data, steam_id, att)
  local bonus = DndCS.calculateSavingThrowBonus(pc_data, att)
  UI.setAttribute(
    "cs_st_"..att.."_bonus_"..steam_id,
    "text",
    bonus >= 0 and "+"..bonus or bonus
  )
end

function DndCS.calculateSavingThrowBonus(pc_data, att)
  return(
  math.floor(pc_data.attributes[att] / 2 - 5) +
  (pc_data.saves[att] == true and pc_data.proficiency_bonus or 0)
  )
end

return DndCS

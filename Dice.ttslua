Dice = {}

-- Globals --

DIE_CLEANUP_DELAY = 5
ROLL_DELAY = 2
ROLL_TIMEOUT = 10
DICE_CLEANUP_DELAY = 5
MAX_DICE = 10 -- WARNING: Set to 0 responsibly.
MAX_WIDTH = 7
XYZ_OFFSET = Vector()

Dice.DIE_TYPE = {
  [4] = "Die_4",
  [6] = "Die_6",
  [8] = "Die_8",
  [10] = "Die_10",
  [12] = "Die_12",
  [20] = "Die_20"
}

Dice.RollStatus = {}

-- Helper Functions --

function spawnObjects(objects)
  assert(#objects > 1, string.format("function spawnObjects requires at least 2 objects, got %d", #objects)
    )
  spawnedObjects = {}
  for i, obj in ipairs(objects) do
    table.insert(spawnedObjects, spawnObject(obj))
  end
  return spawnedObjects
end

function wait(time)
    local start = os.time()
    repeat coroutine.yield(0) until os.time() > start + time
end

function calcDiePosOffsetInRow(i, diceCount)
  local width = MAX_WIDTH * diceCount / MAX_DICE
  local sep = diceCount > 1 and width / (diceCount - 1) or 0
  local x = sep * (i - ((diceCount - 1) / 2))
  return Vector(x, 0, 0)
end

-- Main Functions --

function Dice.click(steam_id, newDieType, allowMultiroll, basePos, bonus, message, onlyAnnounceToColor, existingTimerName)
  if Dice.RollStatus[steam_id] ~= nil and not allowMultiroll then return end
  if Dice.RollStatus.rolling or (not DIE_MULTIROLL and #dice ~= 0) then return end
  for i, die in ipairs(active_pc.dice) do
    die.setPositionSmooth(basePos + calcDiePosOffsetInRow(i, dice), false, true)
  end
  table.insert(active_pc.dice, spawnObject({
    type = newDieType,
    position = basePos + calcDiePosOffsetInRow(#dice + 1, #dice + 1),
    callback_function = function(die) die.setLock(true) end
  }))
  return Dice.waitForRoll(dice, bonus, message, existingTimerName, onlyAnnounceToColor)
end

function Dice.waitForRoll(dice, active_pc, bonus, message, onlyAnnounceToColor, existingTimerName)
  if existingTimerName ~= nil then Wait.stop(existingTimerName) end
  return Wait.time(
  function () Dice.rollDice(dice, bonus, message, onlyAnnounceToColor) end,
  ROLL_DELAY
  )
end

function Dice.rollDice(dice, active_pc, bonus, message, onlyAnnounceToColor)
  function coroutine_rollDice()
    wait(ROLL_DELAY)
    for _, die in ipairs(dice) do
      die.setLock(false)
      die.roll()
      wait(0.1)
    end
    Dice.monitorDice(dice, player, bonus, message, onlyAnnounceToColor)
    return 1
  end
  startLuaCoroutine(self, "coroutine_rollDice")
end

function Dice.spawnDie(rollInProgress, diceCount, spawnBasePos)
  local denyRoll = false
  if MAX_DICE > 0 and diceCount >= MAX_DICE then
    return
  end
  if not rollInProgress and denyRoll == false then
    for i, die in ipairs(currentDice) do
      die.setPositionSmooth(getPositionInLine(i), false, true)
    end
  end

end

function Dice.monitorDice(dice, bonus, message, onlyAnnounceToColor)
  function coroutine_monitorDice()
    local start_time = os.time()
    repeat
      local resting = true
      for _, die in ipairs(dice) do
        if die ~= nil and die.resting == false then
          resting = false
          break
        end
      end
      coroutine.yield(0)
    until resting == true or start_time + ROLL_TIMEOUT < os.time()
    Dice.announceRoll(dice, bonus, message, onlyAnnounceToColor)
    Dice.cleanupDice(dice)
    return 1
  end
  startLuaCoroutine(self, "coroutine_monitorDice")
end

function Dice.announceRoll(dice, bonus, message, onlyAnnounceToColor)
  local total = 0
  local rolls = {}

  for i, die in ipairs(dice) do
    local value = die.getValue()
    total = total + value
    table.insert(rolls, value)
    message = message .. value .. (i ~= #dice and ", " or "")
  end
  if bonus ~= nil then
    message = message .. string.format(" ("..(bonus >= 0 and "+%d)" or "%d)"), bonus)
    total = total + bonus
  end
  if #dice ~= 1 or bonus ~= nil then
    message = message .. string.format(" for a total of %d", total)
  end
  if onlyAnnounceToColor ~= nil then
    broadcastToColor(message, onlyAnnounceToColor, {1,1,1})
  else
    broadcastToAll(message, {1,1,1})
  end
end

function Dice.cleanupDice(dice, active_pc)
  Wait.time(
  function()
    for _, die in pairs(dice) do
      die.destruct()
    end
  end,
  DICE_CLEANUP_DELAY
  )
end

return Dice
